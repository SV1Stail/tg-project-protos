// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: proto/queue_scheduler/queue_scheduler.proto

package queue_scheduler_pb

import (
	context "context"
	publish_post "github.com/SV1Stail/tg-project-protos/gen/go/queue_scheduler/publish_post"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Queuescheduler_CreatePost_FullMethodName             = "/queue_scheduler.Queuescheduler/CreatePost"
	Queuescheduler_CreatePostSomeChannels_FullMethodName = "/queue_scheduler.Queuescheduler/CreatePostSomeChannels"
	Queuescheduler_UpdatePost_FullMethodName             = "/queue_scheduler.Queuescheduler/UpdatePost"
	Queuescheduler_DeletePost_FullMethodName             = "/queue_scheduler.Queuescheduler/DeletePost"
	Queuescheduler_GetPost_FullMethodName                = "/queue_scheduler.Queuescheduler/GetPost"
	Queuescheduler_GetPostsForChannel_FullMethodName     = "/queue_scheduler.Queuescheduler/GetPostsForChannel"
)

// QueueschedulerClient is the client API for Queuescheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueueschedulerClient interface {
	CreatePost(ctx context.Context, in *publish_post.CreatePostRequest, opts ...grpc.CallOption) (*publish_post.CreatePostResponse, error)
	CreatePostSomeChannels(ctx context.Context, in *publish_post.CreatePostSomeChannelsRequest, opts ...grpc.CallOption) (*publish_post.CreatePostSomeChannelsResponse, error)
	UpdatePost(ctx context.Context, in *publish_post.UpdatePostRequest, opts ...grpc.CallOption) (*publish_post.UpdatePostResponse, error)
	DeletePost(ctx context.Context, in *publish_post.DeletePostRequest, opts ...grpc.CallOption) (*publish_post.DeletePostResponse, error)
	GetPost(ctx context.Context, in *publish_post.GetPostRequest, opts ...grpc.CallOption) (*publish_post.GetPostResponse, error)
	GetPostsForChannel(ctx context.Context, in *publish_post.GetPostsForChannelRequest, opts ...grpc.CallOption) (*publish_post.GetPostsForChannelResponse, error)
}

type queueschedulerClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueschedulerClient(cc grpc.ClientConnInterface) QueueschedulerClient {
	return &queueschedulerClient{cc}
}

func (c *queueschedulerClient) CreatePost(ctx context.Context, in *publish_post.CreatePostRequest, opts ...grpc.CallOption) (*publish_post.CreatePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.CreatePostResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_CreatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueschedulerClient) CreatePostSomeChannels(ctx context.Context, in *publish_post.CreatePostSomeChannelsRequest, opts ...grpc.CallOption) (*publish_post.CreatePostSomeChannelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.CreatePostSomeChannelsResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_CreatePostSomeChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueschedulerClient) UpdatePost(ctx context.Context, in *publish_post.UpdatePostRequest, opts ...grpc.CallOption) (*publish_post.UpdatePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.UpdatePostResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_UpdatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueschedulerClient) DeletePost(ctx context.Context, in *publish_post.DeletePostRequest, opts ...grpc.CallOption) (*publish_post.DeletePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.DeletePostResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_DeletePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueschedulerClient) GetPost(ctx context.Context, in *publish_post.GetPostRequest, opts ...grpc.CallOption) (*publish_post.GetPostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.GetPostResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_GetPost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueschedulerClient) GetPostsForChannel(ctx context.Context, in *publish_post.GetPostsForChannelRequest, opts ...grpc.CallOption) (*publish_post.GetPostsForChannelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(publish_post.GetPostsForChannelResponse)
	err := c.cc.Invoke(ctx, Queuescheduler_GetPostsForChannel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueschedulerServer is the server API for Queuescheduler service.
// All implementations must embed UnimplementedQueueschedulerServer
// for forward compatibility.
type QueueschedulerServer interface {
	CreatePost(context.Context, *publish_post.CreatePostRequest) (*publish_post.CreatePostResponse, error)
	CreatePostSomeChannels(context.Context, *publish_post.CreatePostSomeChannelsRequest) (*publish_post.CreatePostSomeChannelsResponse, error)
	UpdatePost(context.Context, *publish_post.UpdatePostRequest) (*publish_post.UpdatePostResponse, error)
	DeletePost(context.Context, *publish_post.DeletePostRequest) (*publish_post.DeletePostResponse, error)
	GetPost(context.Context, *publish_post.GetPostRequest) (*publish_post.GetPostResponse, error)
	GetPostsForChannel(context.Context, *publish_post.GetPostsForChannelRequest) (*publish_post.GetPostsForChannelResponse, error)
	mustEmbedUnimplementedQueueschedulerServer()
}

// UnimplementedQueueschedulerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueschedulerServer struct{}

func (UnimplementedQueueschedulerServer) CreatePost(context.Context, *publish_post.CreatePostRequest) (*publish_post.CreatePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePost not implemented")
}
func (UnimplementedQueueschedulerServer) CreatePostSomeChannels(context.Context, *publish_post.CreatePostSomeChannelsRequest) (*publish_post.CreatePostSomeChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePostSomeChannels not implemented")
}
func (UnimplementedQueueschedulerServer) UpdatePost(context.Context, *publish_post.UpdatePostRequest) (*publish_post.UpdatePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePost not implemented")
}
func (UnimplementedQueueschedulerServer) DeletePost(context.Context, *publish_post.DeletePostRequest) (*publish_post.DeletePostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePost not implemented")
}
func (UnimplementedQueueschedulerServer) GetPost(context.Context, *publish_post.GetPostRequest) (*publish_post.GetPostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPost not implemented")
}
func (UnimplementedQueueschedulerServer) GetPostsForChannel(context.Context, *publish_post.GetPostsForChannelRequest) (*publish_post.GetPostsForChannelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPostsForChannel not implemented")
}
func (UnimplementedQueueschedulerServer) mustEmbedUnimplementedQueueschedulerServer() {}
func (UnimplementedQueueschedulerServer) testEmbeddedByValue()                        {}

// UnsafeQueueschedulerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueschedulerServer will
// result in compilation errors.
type UnsafeQueueschedulerServer interface {
	mustEmbedUnimplementedQueueschedulerServer()
}

func RegisterQueueschedulerServer(s grpc.ServiceRegistrar, srv QueueschedulerServer) {
	// If the following call pancis, it indicates UnimplementedQueueschedulerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Queuescheduler_ServiceDesc, srv)
}

func _Queuescheduler_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.CreatePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_CreatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).CreatePost(ctx, req.(*publish_post.CreatePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queuescheduler_CreatePostSomeChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.CreatePostSomeChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).CreatePostSomeChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_CreatePostSomeChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).CreatePostSomeChannels(ctx, req.(*publish_post.CreatePostSomeChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queuescheduler_UpdatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.UpdatePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).UpdatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_UpdatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).UpdatePost(ctx, req.(*publish_post.UpdatePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queuescheduler_DeletePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.DeletePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).DeletePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_DeletePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).DeletePost(ctx, req.(*publish_post.DeletePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queuescheduler_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.GetPostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).GetPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_GetPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).GetPost(ctx, req.(*publish_post.GetPostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queuescheduler_GetPostsForChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(publish_post.GetPostsForChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueschedulerServer).GetPostsForChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Queuescheduler_GetPostsForChannel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueschedulerServer).GetPostsForChannel(ctx, req.(*publish_post.GetPostsForChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Queuescheduler_ServiceDesc is the grpc.ServiceDesc for Queuescheduler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Queuescheduler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "queue_scheduler.Queuescheduler",
	HandlerType: (*QueueschedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePost",
			Handler:    _Queuescheduler_CreatePost_Handler,
		},
		{
			MethodName: "CreatePostSomeChannels",
			Handler:    _Queuescheduler_CreatePostSomeChannels_Handler,
		},
		{
			MethodName: "UpdatePost",
			Handler:    _Queuescheduler_UpdatePost_Handler,
		},
		{
			MethodName: "DeletePost",
			Handler:    _Queuescheduler_DeletePost_Handler,
		},
		{
			MethodName: "GetPost",
			Handler:    _Queuescheduler_GetPost_Handler,
		},
		{
			MethodName: "GetPostsForChannel",
			Handler:    _Queuescheduler_GetPostsForChannel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/queue_scheduler/queue_scheduler.proto",
}
